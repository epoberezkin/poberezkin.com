<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Evgeny Poberezkin - Haskell — a higher order language</title>
    <meta name="description" content="Evgeny Poberezkin's blog">
    <meta name="author" content="Evgeny Poberezkin">
    <meta property="og:title" content="Haskell — a higher order language">
    <meta property="og:url" content="https://www.poberezkin.com//posts/2020-03-15-haskell-a-higher-order-language.html">
    <meta itemprop="name" content="Haskell — a higher order language">
    <meta name="twitter:title" content="Haskell — a higher order language">
    <meta name="twitter:site" content="@epoberezkin">
    <meta name="twitter:creator" content="@epoberezkin">
    
      <meta property="og:image" content="https://www.poberezkin.com/images/haskell.png">
      <meta itemprop="image" content="https://www.poberezkin.com/images/haskell.png">
      <meta name="twitter:image:src" content="https://www.poberezkin.com/images/haskell.png">
    
    <link rel="alternate" title="Evgeny Poberezkin" type="application/atom+xml" href="../feed.atom">
    <link rel="alternate" title="Evgeny Poberezkin" type="application/rss+xml" href="../feed.rss">
    <link rel="stylesheet" href="../css/default.css" />
    <link rel="stylesheet" href="../css/syntax.css" />
  </head>
  <body>
    <div class="container">
      <nav role="navigation">
        <div class="source">
          <div><a href="https://github.com/epoberezkin/poberezkin.com">source code</a></div>
          <div><a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA</a></div>
        </div>
        <div class="logo">
          <a href="../">Evgeny Poberezkin</a>
        </div>
        <a class="nav" href="../">Blog</a>
        <a class="nav" href="../tags/security.html">#security</a>
        <a class="nav" href="../tags/coding.html">#coding</a>
        <a class="nav" href="../tags/haskell.html">#haskell</a>
        <a class="nav" href="../tags/talk.html">#talk</a>
        <a class="nav" href="../about.html">About</a>
      </nav>

      <main role="main">
        <h1>Haskell — a higher order language</h1>
        <article>
  <section class="header">
    <div class="info">
      Posted on
      
        <a href="https://medium.com/@epoberezkin/haskell-a-higher-order-language-ade461d453c7">March 15, 2020</a>
      
      
        by Evgeny Poberezkin
      
    </div>
    <div class="info">
      
        Tags: <a title="All pages tagged 'haskell'." href="../tags/haskell.html" rel="tag">haskell</a>, <a title="All pages tagged 'executable'." href="../tags/executable.html" rel="tag">executable</a>, <a title="All pages tagged 'coding'." href="../tags/coding.html" rel="tag">coding</a>
      
    </div>
  </section>
  <section>
    <p><img src="../images/haskell.png" width="40%" style="float: left; margin: 20px 20px 10px 0;"></p>
<p>The thesis here is that Haskell is not just one of many functional programming languages — it is a different, more advanced programming paradigm.</p>
<p>Haskell is indeed a functional language, but calling Haskell “a functional language” is like calling a skyscraper “a dwelling” — while technically correct, it does not describe how the latter is much more than just a place to live.</p>
<p>What defines a programming language? From the point of view of category theory, there are two major components of each programming language: data types and transformations between them — in category theory terminology, “objects” and “morphisms”.</p>
<p><strong>The first claim</strong> here (that must be challenged) is that all programming languages but Haskell (and more recent Idris) are based on “morphisms” — code, procedures or functions that transform and manipulate the data. Data types in these languages play the secondary role — to ensure validity and to improve predictability of the “morphisms”.</p>
<p>Haskell, being a functional language, counterintuitively, is not based on functions — it is based on types, or “objects” in category theory terminology. Types ensuring the validity of transformations almost seems secondary in Haskell (however useful), while the primary purpose of types is to formally describe the system model and the relationship between the elements of the system (including functions that also have types).</p>
<p>But a bigger distinction between Haskell and other languages is in the nature of the language semantics. <strong>The second claim</strong> (that also must be challenged) is that while other languages have semantics tightly coupled with the syntax — the meaning of the code is defined by its grammar, Haskell semantics is defined by the combination of code and context (e.g., created by the types that belong to Monad class). In this way, Haskell is much closer than other programming languages to the natural human languages that also have semantics defined by the combination of grammar and context (see interpretive and generative semantics of human languages).</p>
<p>For example, a simple <code>sequence</code> function that is defined as:</p>
<pre class="haskell-ignore"><code>sequence :: Monad m =&gt; [m a] -&gt; m [a]
sequence ms = foldr k (return []) ms
            where
              k m m' = do { x &lt;- m; xs &lt;- m'; return (x:xs) }</code></pre>
<p>can mean different things depending on the context that is defined by <code>m</code>.</p>
<p>Applied to IO it can mean performing IO actions in sequence:</p>
<pre class="haskell-ignore"><code>sequence [getLine, getLine]</code></pre>
<p>returns a single IO action that resolves into the list of 2 strings.</p>
<p>Applied to the list of instances of <code>Maybe</code> type, it would check that all of them contain some value and either return <code>Just</code> list of these value or Nothing if any of them is <code>Nothing</code>:</p>
<pre class="haskell-ignore"><code>sequence [Just 1, Just 2, Just 3] = Just [1, 2, 3]
sequence [Just 1, Just 2, Nothing] = Nothing</code></pre>
<p>Applied to the list of 2 lists, it will perform indeterminate computation and return all possible permutations of list items where the first item comes from the first list, and the second — from the second list:</p>
<pre class="haskell-ignore"><code>sequence [[1,2],[3,4]] = [[1,3],[1,4],[2,3],[2,4]]
sequence [[1,2],[3,4], []] = [] -- [] is &quot;undefined&quot; in this context</code></pre>
<p>Context-dependent semantics of Haskell code makes Haskell more difficult to learn. As the same syntax can mean many different things, achieving fluency requires more effort than with other languages. But it also makes Haskell infinitely more expressive than any other language — you can implement any new semantics you want by adding the new context to the same code. Therefore, while Haskell requires more investment from you than other programming languages, the return on this investment is infinitely higher.</p>
<p>Some Haskell books (e.g. <a href="https://learnyouahaskell.github.io">LYAH</a>) and lectures (e.g <a href="https://www.seas.upenn.edu/~cis194/fall16/index.html">Penn course</a>) do not capture this fundamental distinction well enough. Instead, they focus on the functional nature of Haskell, and present Monad as almost some work-around to allow using pure functions for context-aware computations (IO, State, indeterminism, etc.). Unfortunately, it creates a barrier to entry for the new developers, because when people are asked to make a larger than usual investment to learn yet one more functional programming language with quirky syntax, this investment is difficult to justify without understanding first that Haskell is a more powerful programming paradigm. How many people abandoned Haskell before grasping its power?</p>
<p>A good book that explains how Haskell is a higher order language is <a href="https://en.wikibooks.org/wiki/Haskell">Haskell</a> in wiki-books. Once you get over “<a href="https://en.wikibooks.org/wiki/Haskell/Understanding_monads">Understanding monads</a>” section, the Haskell advantage should become apparent.</p>
<p>If you want to see some relatively simple magic you can do with Haskell, watch the talk by <a href="https://github.com/EncodePanda">Paweł Szulc</a> at Lambda World’19, particularly where he <a href="https://www.youtube.com/watch?v=idU7GdlfP9Q&amp;feature=youtu.be&amp;t=625">talks about Servant</a> — the library to create REST APIs in Haskell. Before you write a single line of implementation code, you can get the whole API definition from a single type definition (I am replacing alpacas from Paweł’s farm with users here):</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DataKinds, DeriveAnyClass, DeriveGeneric, TypeOperators #-}</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Servant</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Servant.Server</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Network.Wai.Handler.Warp</span> (run)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Aeson</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Generics</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">M</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">User</span> <span class="ot">=</span> <span class="dt">User</span> {</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="ot">  name  ::</span> <span class="dt">String</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>} <span class="kw">deriving</span> (<span class="dt">Generic</span>, <span class="dt">ToJSON</span>, <span class="dt">FromJSON</span>)</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">UserAPI</span> <span class="ot">=</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>       <span class="st">&quot;user&quot;</span> <span class="op">:&gt;</span> <span class="dt">Get</span> '[<span class="dt">JSON</span>] (<span class="dt">M.Map</span> <span class="dt">Int</span> <span class="dt">User</span>)</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">:&lt;|&gt;</span> <span class="st">&quot;user&quot;</span> <span class="op">:&gt;</span> <span class="dt">Capture</span> <span class="st">&quot;userId&quot;</span> <span class="dt">Int</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>              <span class="op">:&gt;</span> <span class="dt">Get</span> '[<span class="dt">JSON</span>] <span class="dt">User</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>  <span class="op">:&lt;|&gt;</span> <span class="st">&quot;user&quot;</span> <span class="op">:&gt;</span> <span class="dt">Capture</span> <span class="st">&quot;userId&quot;</span> <span class="dt">Int</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>              <span class="op">:&gt;</span> <span class="dt">ReqBody</span> '[<span class="dt">JSON</span>] <span class="dt">User</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>              <span class="op">:&gt;</span> <span class="dt">PutCreated</span> '[<span class="dt">JSON</span>] <span class="dt">NoContent</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a><span class="ot">userApi ::</span> <span class="dt">Proxy</span> <span class="dt">UserAPI</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>userApi <span class="ot">=</span> <span class="dt">Proxy</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a><span class="co">-- UserAPI type defines this API:</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a><span class="co">-- GET /user   - Response: {&quot;1&quot;:{&quot;name&quot;:&quot;jane&quot;}}, 200</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a><span class="co">-- GET /user/1 - Response: {&quot;name&quot;:&quot;jane&quot;}, 200</span></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a><span class="co">-- PUT /user/2 Body: {&quot;name&quot;:&quot;John D.&quot;} - Response: NoContent, 201</span></span></code></pre></div>
<p>And before you even start implementing this API you can get client functions to call this API with a few lines of code:</p>
<pre class="haskell-ignore"><code>-- import Servant.Client

getAll :&lt;|&gt; getUser :&lt;|&gt; putUser = client userApi

-- client functions types:
getAll :: ClientM (M.Map Int User)
getUser :: Int -&gt; ClientM User
putUser :: Int -&gt; User -&gt; ClientM User</code></pre>
<p>With just a few annotations you can generate API docs from UserAPI type:</p>
<pre class="haskell-ignore"><code>instance ToCapture (Capture &quot;userId&quot; Int) where
  toCapture _ =
    DocCapture &quot;userId&quot;
               &quot;Id that uniquely identifies a user in the system&quot;

instance ToSample (User) where
  toSamples _ = singleSample $ User &quot;Jane&quot;

instance ToSample (M.Map Int User) where
  toSamples _ = singleSample $ M.singleton 1 (User &quot;Jane&quot;)

apiDocs :: API
apiDocs = docs userApi

main :: IO ()
main = (writeFile &quot;docs.md&quot; . markdown) apiDocs</code></pre>
<p>To run this server you just need to implement it, the mock implementation is very simple, but the Haskell type system ensures that the type of implementation is correct (<code>Server UserAPI</code> that is based on <code>UserAPI</code> type):</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>dummy <span class="ot">=</span> <span class="dt">User</span> <span class="st">&quot;Jane&quot;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="ot">fetchAll ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m (<span class="dt">M.Map</span> <span class="dt">Int</span> <span class="dt">User</span>)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>fetchAll <span class="ot">=</span> <span class="fu">pure</span> <span class="op">$</span> M.singleton <span class="dv">1</span> dummy</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="ot">fetch ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> m <span class="dt">User</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>fetch <span class="fu">id</span> <span class="ot">=</span> <span class="fu">pure</span> dummy</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="ot">insert ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">User</span> <span class="ot">-&gt;</span> m <span class="dt">NoContent</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>insert <span class="fu">id</span> user <span class="ot">=</span> <span class="fu">pure</span> <span class="dt">NoContent</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="ot">server ::</span> <span class="dt">Server</span> <span class="dt">UserAPI</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>server <span class="ot">=</span> fetchAll <span class="op">:&lt;|&gt;</span> fetch <span class="op">:&lt;|&gt;</span> insert</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span class="ot">app ::</span> <span class="dt">Application</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>app <span class="ot">=</span> serve userApi server</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;http://localhost:8080/user&quot;</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>  run <span class="dv">8080</span> app</span></code></pre></div>
<p>The above does feel like magic! You can run this server right from this post with <code>stack run users-api</code>.</p>
<p>Morphism-based programming languages (i.e., all other languages) force programmers to model the whole system outside of the code — using SQL schema, JSON schema, diagrams, etc. Type-based languages (Haskell and Idris) allow for type-driven development, when the whole system can be modelled top-down with algebraic data types, rather than bottom-up with functions as in other languages.</p>
<p>Haskell being type-based language with context-dependent semantics is a higher order language that is almost one of a kind — there seems to be no other mature programming language that allows the same level of expressiveness as Haskell does.</p>
  </section>
  <section class="links">
    <a href="https://www.reddit.com/submit?url=https%3A%2F%2Fwww.poberezkin.com%2Fposts%2F2020-03-15-haskell-a-higher-order-language.html&title=Haskell — a higher order language" target="_blank"><img src="../images/reddit.png"></a>
    <a href="https://twitter.com/intent/tweet?via=epoberezkin&text=Haskell%20%E2%80%94%20a%20higher%20order%20language&hashtags=haskell%2Cexecutable%2Ccoding&original_referer=https%3A%2F%2Fwww.poberezkin.com%2Fposts%2F2020-03-15-haskell-a-higher-order-language.html&url=https%3A%2F%2Fwww.poberezkin.com%2Fposts%2F2020-03-15-haskell-a-higher-order-language.html" target="_blank"><img src="../images/tweet.png"></a>
    
  </section>
</article>

      </main>
    </div>
  </body>
</html>
